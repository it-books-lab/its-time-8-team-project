

##  4. 버디 매칭

### 4.1 매칭 로직

* **내용**: 전공/학교/관심사 기반 점수화 → 우선순위 매칭
* **난이도**: ⚠️ 어려움 (추천/매칭 알고리즘 구현 필요)
* **이유**:

  * 단순한 "랜덤 매칭"이 아니라, 공통 속성(전공/학교/관심사)을 점수화해서 가중치 계산 필요.
  * 예: 같은 학교면 +50점, 같은 전공이면 +30점, 같은 관심사면 +10점 … 이런 규칙.
  * 이 점수 기반으로 정렬 후 최적의 매칭을 찾아야 함.
* **구현 개념**:

  1. 사용자 A의 속성 가져오기
  2. 다른 모든 사용자와 "유사도 점수" 계산
  3. 점수 높은 순으로 정렬 → 최상위 몇 명 추천
  4. 데이터가 많아지면 캐싱 or 추천 시스템(DB 튜닝) 필요

---

### 4.2 필터링

* **내용**: 성별/학년/위치 기반 매칭 필터
* **난이도**: ⚪ 중간
* **이유**:

  * 단순한 조건문 → DB 쿼리 `WHERE gender = 'F' AND year = 3` 같은 형태.
  * 다만 위치 기반이면 좌표(위도/경도) → 거리 계산이 필요 (`haversine formula` 사용).
* **구현 개념**:

  * `SELECT * FROM users WHERE gender = 'F' AND year = 3 AND distance(user.location, target.location) < 10km`

---

### 4.3 매칭 주기

* **내용**: 하루 1회 추천, 주 1회 자동 페어링
* **난이도**: ⚪ 중간
* **이유**:

  * 스케줄러(Cron Job, Spring Scheduler, 배치 작업) 설정 필요.
  * "하루 1회"는 추천만, "주 1회"는 진짜 매칭 확정.
* **구현 개념**:

  * Spring Boot → `@Scheduled(cron = "...")`
  * 추천 결과를 캐싱(DB 저장), 주 1회는 `match_pairs()` 실행

---

### 4.4 UX

* **내용**: Swipe UI, Reject 시 재추천 큐 반영
* **난이도**: ⚠️ 중간~어려움 (프론트 연동 난이도↑)
* **이유**:

  * 백엔드 입장에서는 Swipe(좌/우) → “수락/거절” 이벤트만 저장.
  * "거절"이면 재추천 큐에 반영 → 동일한 사람 반복 추천 방지.
* **구현 개념**:

  * DB에 `user_match_history` 테이블 만들어서

    * `user_id, buddy_id, action(ACCEPT/REJECT), timestamp` 저장
  * 추천 로직 실행 시 "이미 REJECT 한 사람"은 제외

---

✅ **정리하면**

* **쉬움**: 필터링(쿼리 조건), 매칭 주기(스케줄러)
* **중간**: UX(거절 처리, 큐 반영)
* **어려움**: 매칭 로직(점수 기반 추천 알고리즘)

---

 **첫 구현**일 시, 추천 진행 방식:

1. **랜덤 매칭 + 기본 필터링** → 빠르게 프로토타입
2. 이후 점수화(전공/학교/관심사) → 추천 정확도 개선
3. 마지막에 Swipe/재추천 큐 반영

---
