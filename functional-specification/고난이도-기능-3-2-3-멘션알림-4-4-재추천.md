

## 3.2.3 멘션/알림

### **목표**

게시글이나 댓글에서 `@닉네임`을 입력하면, 해당 유저에게 **실시간으로 알림**을 보내주는 기능.

### **구현 단계**

1. **@닉네임 파싱**

   * 작성한 글에서 `@` 기호 뒤에 닉네임이 있는지 **정규식(Regex)**으로 찾아냄

   ```java
   Pattern pattern = Pattern.compile("@([a-zA-Z0-9_]+)");
   Matcher matcher = pattern.matcher(content);
   while (matcher.find()) {
       String nickname = matcher.group(1);
       // nickname → user_id 매핑
   }
   ```

2. **닉네임 → user_id 매핑**

   * DB에서 해당 닉네임이 누구인지 조회
   * 여러 명 중 겹치면 **정책(첫 가입자 우선 등)** 결정

3. **알림 테이블에 insert**

   * 테이블 예시:

   ```sql
   notifications (
       id INT PK,
       user_id INT,          -- 알림 받을 사람
       from_user_id INT,     -- 멘션한 사람
       type ENUM('MENTION','LIKE', ...),
       post_id INT,
       read_flag BOOLEAN,
       created_at TIMESTAMP
   )
   ```

4. **실시간 알림 처리**

   * **웹소켓(WebSocket)**: 서버와 클라이언트가 항상 연결된 상태로, 글 작성과 동시에 바로 알림 전송 가능
   * **푸시(Push Notification)**: 앱이 백그라운드 상태여도 OS 알림으로 표시
   * 일반 웹 환경: JS에서 WebSocket 연결 후 알림 수신 → UI 업데이트
   * 모바일 앱: Firebase Cloud Messaging(FCM) 등으로 푸시 전송

### **어려운 점**

* 멘션 자동완성: `@` 입력 시 추천 닉네임 리스트 띄우기
  → DB에서 실시간 검색 + 속도 최적화 필요
* 실시간 알림 처리: 웹소켓 서버 구축 + 연결 관리, 푸시 토큰 관리
* 알림 DB 설계: 읽음/안읽음 상태, 삭제, 푸시 전송 여부 등 고려 필요

---

## 4.4 Swipe UI + Reject 재추천 큐

### **목표**

버디 매칭에서 **사용자가 좌/우 스와이프** → ACCEPT/REJECT 이벤트 기록
→ 거절한 사람은 일정 기간 동안 다시 추천되지 않도록 관리

### **구현 단계 (백엔드 관점)**

1. **user_match_history 테이블**

```sql
user_match_history (
    id INT PK,
    user_id INT,        -- 현재 사용자
    buddy_id INT,       -- 매칭 대상
    action ENUM('ACCEPT','REJECT'),
    timestamp TIMESTAMP
)
```

2. **Swipe 이벤트 처리**

* 프론트에서 좌/우 스와이프 → HTTP 요청으로 서버 전달

```json
POST /api/match/action
{
    "userId": 101,
    "buddyId": 202,
    "action": "REJECT"
}
```

* 서버는 user_match_history에 저장

3. **재추천 큐 적용**

* 추천 로직에서 후보 그룹 생성 시

```sql
SELECT * FROM users
WHERE id NOT IN (
    SELECT buddy_id FROM user_match_history
    WHERE user_id = 101 AND action='REJECT'
    AND timestamp > now() - interval '14 days'
)
```

* → 14일 내에 거절한 사람 제외

### **어려운 점**

* **프론트와 실시간 연동**: 스와이프 애니메이션 → 서버 저장 → 다시 카드 렌더링
* **재추천 큐 정책**: 몇 일 동안 재추천 금지? 잔여 횟수 제한?
* **트랜잭션 관리**: 동시에 여러 사용자가 추천 받거나 Swipe 시, race condition 주의

---

## **“프론트와 실시간 연동”** 상황 부연설명

---

### 서비스 플로우

1. 앱에서 사용자가 **좌/우 스와이프**:
    - 오른쪽 → ACCEPT
    - 왼쪽 → REJECT
2. 프론트(앱)는 **즉시 스와이프 애니메이션**을 보여줌
    
    → 사용자 경험(UX)을 위해 화면에서 카드가 바로 사라지는 효과
    
3. 동시에 프론트는 **서버에 HTTP 요청**을 보냄:

```json
POST /api/match/action
{
    "userId": 101,
    "buddyId": 202,
    "action": "REJECT"
}

```

1. 서버는 `user_match_history`에 기록하고 **추천 후보에서 제외**
2. 프론트는 **서버 응답**을 받아 카드 데이터 갱신:
    - 다음 추천 후보 카드 로드
    - 잔여 추천 횟수/리롤 정보 갱신

---

## 왜 실시간 연동이 필요한가?

- UX 관점: 카드 스와이프 → 바로 화면 변화 필요
    - 서버 응답을 기다리면서 멈추면 앱이 느리게 느껴짐
- 추천 로직과 일관성을 유지:
    - 같은 사용자가 여러 기기/세션에서 동시에 스와이프할 수도 있음
    - 서버 저장이 늦으면 **중복 추천, 잘못된 재추천 큐** 발생

즉, **프론트에서 즉시 반응 + 서버에서 정확한 상태 기록**을 동시에 관리해야 해서 실시간 연동이 필요.

---

## 구현 팁

1. **낙관적 UI(Optimistic UI)** 적용:
    - 프론트가 먼저 스와이프 애니메이션 실행
    - 서버 성공 시 그대로 두고, 실패 시 롤백
2. **비동기 요청**:
    - 스와이프마다 Ajax/Fetch/Retrofit으로 POST 요청
    - 서버 응답 기다리지 않고 다음 카드 렌더링
3. **Race Condition 방지**:
    - 동시에 여러 요청 들어와도 DB 트랜잭션으로 `user_match_history` 무결성 유지
    - UNIQUE(user_id, buddy_id) 또는 UPSERT 사용 가능


---

### 정리:

| 항목             | 핵심 포인트                                         |
| -------------- | ---------------------------------------------- |
| 멘션/알림          | 정규식 파싱 → user_id 매핑 → 알림 DB → 웹소켓/푸시 전송        |
| Swipe + Reject | user_match_history 기록 → 추천 로직에서 제외 → 프론트 연동 필요 |

---

