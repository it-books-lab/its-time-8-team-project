

## **3 글로벌 커뮤니티**

### 3.1 그룹 탐색/가입

* **3.1.1 추천 목록**

  * 구현: 온보딩에서 입력한 관심사, 언어, 활동시간을 기반으로 DB에서 유사 그룹을 뽑아 랭킹/추천.
  * 난이도: **중~상** (추천 알고리즘이 단순하면 쉽지만, 정교하게 만들려면 어려움).
  * 어려운 점: 추천 품질 → 단순히 태그 매칭만 할지, 협업 필터링 같은 ML을 붙일지 결정해야 함.
 
  - 단순 태그 매칭
    - 온보딩에서 사용자가 선택한 관심사, 언어, 활동시간과
    - 그룹에 설정된 태그를 비교해서 같은 태그가 많은 순서대로 추천.
    - 구현 쉬움 → `SQL WHERE tag IN (...) ORDER BY COUNT(*) DESC` 정도면 가능. 
    - 다른 사용자 행동(좋아요, 가입 기록 등)을 반영하지 못함.

  - 협업 필터링(Collaborative Filtering, CF)
    - 사용자 행동 기반 추천.
    - 예: “A 사용자가 좋아한 그룹을 B 사용자도 좋아할 확률이 높다” → 비슷한 사용자끼리 추천.
    - 구현 방법: ML 또는 라이브러리 필요
    - User-based CF: 유사한 사용자 행동을 기준
    - Item-based CF: 그룹끼리 유사성을 기준
    - 장점: 단순 태그보다 정교하고 개인화 가능
    - 단점: 구현 난이도 높음, 초기 사용자/데이터가 적으면 Cold-start 문제 발생
  
->  즉, MVP에서는 단순 태그 매칭으로 시작하고, 나중에 CF 도입하는 식이 현실적



* **3.1.2 검색/필터**

  * 구현: 그룹 테이블에 `name`, `tags`, `language` 컬럼 두고 SQL LIKE 검색 + WHERE 조건 필터링.
  * 난이도: **하** (검색 성능이 문제되면 Elasticsearch 같은 검색엔진 필요).
  * 어려운 점: 데이터 많아지면 검색 속도 & 필터링 최적화.
 
  * Elasticsearch
     - 검색 엔진(Search Engine) 중 하나.
     - 빠르고 정교한 텍스트 검색에 특화.
     - 예시: 게시글 검색, 태그 검색, 언어 필터 등
     - 특징:   
       - 정규 DB보다 텍스트 검색 속도와 기능이 뛰어남
       - 자동 완성, 유사 단어 검색, 랭킹 제공 가능
     - 유료/무료:
       - 오픈소스 버전 있음 (Elasticsearch OSS) → 직접 서버에 설치 가능
       - Elastic Cloud → 공식 유료 클라우드 서비스
  

* **3.1.3 가입/탈퇴**

  * 구현: `group_membership` 테이블 만들어 user_id, group_id 저장/삭제.
  * 난이도: **하**.
  * 어려운 점: 공개 그룹은 단순하지만, 향후 **비공개 그룹/승인제** 요구가 생기면 복잡해짐.

---

### 3.2 게시판 (게시글/댓글)

* **3.2.1 게시글 작성/수정/삭제**

  * 구현: CRUD API + DB 저장. 초안 자동저장은 프론트에서 LocalStorage나 백엔드 draft 컬럼.
  * 난이도: **중**.
  * 어려운 점: 작성 빈도 제한(분당 2회) → Redis 같은 분산락/레이트리미터 필요.
 
  *  LocalStorage / draft 컬럼
     - **LocalStorage**: 브라우저에 임시로 저장하는 공간
         - 글 작성 중 새로고침해도 임시 저장된 내용 복원 가능
     - **draft 컬럼**: DB 테이블 내 임시 저장용 컬럼
         - 서버에 임시로 저장하고, 완료되면 `published = true` 로 게시
      
  - Redis 같은 분산락 / 레이트리미터
      - **Redis**: 메모리 기반 DB, 속도가 매우 빠름
      - **분산락(Distributed Lock)**: 여러 서버에서 동시에 접근할 때 충돌 방지
          - 예: 글 작성 횟수 제한 → 동시에 여러 서버에서 요청해도 2회 제한을 지킬 수 있음
      - **레이트리미터(Rate Limiter)**: 단위 시간당 요청 횟수 제한
          - 예: 분당 2회 이상 글 작성 방지

* **3.2.2 댓글/스레드**

  * 구현: `comments` 테이블 (post_id, parent_id) 구조로 대댓글 스레드.
  * 난이도: **중**.
  * 어려운 점: 깊은 스레드 구조 → 트리 쿼리 최적화 필요.

  - 스레드(Thread) 구조
    - 댓글의 **대댓글 관계**를 트리 구조로 표현한 것
    - 예시:
    
    ```
    게시글
     ├─ 댓글1
     │    ├─ 대댓글1-1
     │    └─ 대댓글1-2
     └─ 댓글2
          └─ 대댓글2-1
    
    ```
    
    - DB 테이블 구조 예시:
    
    ```sql
    comments (
      id INT PK,
      post_id INT,       -- 어느 게시글에 속하는지
      parent_id INT NULL,-- NULL이면 일반 댓글, 값 있으면 대댓글
      user_id INT,
      content TEXT
    )
    
    ```
    
    - 깊은 트리 구조는 쿼리 복잡도가 높아서 **재귀 쿼리 또는 계층형 쿼리 최적화** 필요


* **3.2.3 멘션/알림**

  * 구현: 정규식으로 `@닉네임` 파싱 → 해당 유저 id 매핑 → 알림 테이블 insert.
  * 난이도: **중~상**.
  * 어려운 점: 멘션 자동완성, 실시간 알림 처리(웹소켓/푸시).

---

### 3.3 안전/모더레이션

* **3.3.1 금지어 필터**

  * 구현: 사전에 등록된 단어 리스트로 체크.
  * 난이도: **하**.
  * 어려운 점: 욕설 우회 표현(예: ㅅㅂ → ㅅㅂㅏ), 다국어 욕설 필터링.

* **3.3.2 신고/차단**

  * 구현: `report`, `block` 테이블. 신고 들어오면 관리자 검토 큐에 적재, 차단 시 서로 콘텐츠 exclude.
  * 난이도: **중**.
  * 어려운 점: 차단 처리 로직이 DB 쿼리에 항상 포함되어야 함 (`WHERE NOT blocked`).

* **3.3.3 쿨다운**

  * 구현: Redis 카운터 + TTL로 일정 시간 내 글쓰기 제한.
  * 난이도: **중**.
  * 어려운 점: 분산환경에서 정확히 레이트 리밋 유지.

---

### 3.4 운영도구 (라이트)

* **3.4.1 숨김/해제**

  * 구현: 게시글/댓글에 `is_hidden` 플래그. 운영자만 토글 가능.
  * 난이도: **하**.
  * 어려운 점: 로그 기록을 남기고, UI에서 운영자만 볼 수 있게 권한체크 필요.

---

## 요약 (난이도 & 포인트)

* **쉬움 (하)**: 그룹 가입/탈퇴, 금지어 필터, 숨김/해제
* **보통 (중)**: 게시글 CRUD, 댓글 스레드, 검색/필터, 신고/차단, 쿨다운
* **어려움 (중~상)**: 추천 목록, 멘션/알림 (실시간성, 정확성)

👉 전반적으로 "글로벌 커뮤니티" 파트는 **기본 기능은 CRUD 수준이라 쉽지만,
추천/알림/실시간 처리/모더레이션** 부분에서 난이도가 확 올라갈 것.

---


