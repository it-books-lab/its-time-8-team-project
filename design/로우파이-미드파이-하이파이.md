# Lo-Fi, Mid-Fi, Hi-Fi에 대한 정의 및 목적, 백엔드가 할 일

참고 - https://gi-do.tistory.com/24

---

## Q. 디자이너와의 소통을 위해 로우파이, 미드파이, 하이파이라는 용어에 대해 찾아보고 있었어. 그런데, 각 프로토타입의 설명이 부족한 것 같아서 내용을 보충해줄래? 특히, 로우파이의 목적이 뭔지 궁금해. 그리고, 이번 정기회의에 디자이너가 로우파이를 설계해오겠다고 했는데, 나는 백엔드 입장에서 로우파이를 어떻게 읽고 어떻게 피드백해주면 될지도 조언해줘.


지금은 **백엔드 입장에서 디자이너와 협업**할 때, 각 Fidelity(정밀도) 단계가 어떤 의미를 가지는지 명확히 아는 게 굉장히 중요합니다. 말씀하신 뼈대에 기반해서, 설명을 풍부하게 채워볼게요.

특히 로우파이(Lo-Fi)는 “**빠르게 전체 구조를 잡고, 기능 흐름을 합의하기 위한 단계**”라는 점이 핵심이에요.

---

## 1. 프로토타입 단계별 설명

### 1. 스케치 (Lo-Fi, 로우파이)

- **형태**: 종이 위의 손그림, 단순한 사각형과 텍스트 중심의 초안
- **목적**:
    - **핵심 구조와 사용자 흐름(UX Flow)을 빠르게 시각화**하는 단계입니다.
    - 구체적인 색상, 폰트, 컴포넌트는 고려하지 않고, **“이 기능이 어디에 있고, 어떤 경로로 이동하는가”**를 파악하는 것이 핵심이에요.
    - 디자이너뿐 아니라 기획자, 백엔드, 프론트엔드 모두가 **“전체 서비스의 큰 그림을 공유”**할 수 있도록 하는 게 목적이에요.
    - 빠르고 싸게 수정하기 위해 로우파이로 시작합니다 — “이 페이지는 진짜 필요할까?”, “이 흐름이 자연스러울까?”를 논의하기 위함이죠.
- **백엔드 입장에서 로우파이를 읽는 방법 & 피드백 포인트**:
    - **데이터 흐름(Data Flow)**:
        - 각 화면에서 어떤 데이터가 표시되는지 확인합니다.
            
            예: “공간 상세 화면 → 공간명, 주소, 태그, 이미지, 리뷰 등 어떤 데이터가 필요한가?”
            
        - 백엔드에서는 그 데이터들이 각각 어떤 API로 전달되어야 할지 미리 짐작할 수 있습니다.
    - **상호작용 포인트(Action Point)**:
        - 사용자가 버튼을 누를 때 서버 통신이 필요한 부분(예: 찜, 예약, 리뷰 등록 등)을 체크합니다.
        - “이 화면에서 서버 요청이 발생하겠구나”를 표시해두면 나중에 API 설계가 수월해져요.
    - **화면 간 이동(Flow)**:
        - 어떤 화면에서 어떤 화면으로 이동하는지를 보면, URL 구조나 라우팅 설계를 떠올릴 수 있습니다.
        - 예를 들어, “리스트 → 상세 → 수정” 구조라면 `/spaces`, `/spaces/{id}`, `/spaces/{id}/edit` 식으로 미리 예상해볼 수 있죠.
    - **피드백 예시**:
        - “이 화면에서 공간 상세 데이터를 어디서 불러오는지 명확히 할까요?”
        - “이 버튼은 서버 요청이 필요한 기능으로 보이는데, 로딩 상태나 실패 시 처리 흐름도 같이 고려하면 좋겠습니다.”

---

### 2. 와이어프레임 (Mid-Fi, 미드파이 = UI 기획서)

- **형태**: 디지털 도구(Figma, XD 등)로 만든 단색 화면, 컴포넌트의 위치와 흐름만 있는 중간 단계
- **목적**:
    - 구체적인 화면 배치와 사용자 흐름(워크플로우)을 설계
    - 아직 색상이나 스타일은 넣지 않지만, **기능 단위의 연결**을 명확히 정의
    - “이 버튼을 누르면 어떤 화면으로 이동하는가?”, “이 입력창은 어떤 데이터를 받는가?” 같은 세부 동작 중심
- **백엔드 입장에서**:
    - 어떤 API 요청이 필요한지 더 명확해지는 단계입니다.
    - API 명세서 초안을 함께 논의하기 좋은 시점이에요.
    - 예: “이 리뷰 등록 폼은 POST /reviews 요청을 사용하면 되겠네요.”

---

### 3. UI 디자인 (Hi-Fi, 하이파이)

- **형태**: 실제 서비스에 가까운 완성형 디자인 (색상, 폰트, 아이콘, 간격 등 모두 정의됨)
- **목적**:
    - 실제 구현 단계에서 프론트엔드가 그대로 반영할 수 있도록 구체적인 시각 요소를 완성
    - 브랜딩 일관성과 사용자 경험(UX)을 최적화
- **백엔드 입장에서**:
    - 데이터 표시 형태(날짜 포맷, 숫자 단위, 소수점 처리 등)를 시각적으로 확인 가능
    - API 응답 구조를 실제 화면 단위에 맞게 미세 조정할 수 있습니다.
    - 예: “리뷰 평균 점수는 소수점 둘째 자리까지만 보여주니까, 응답을 그렇게 포맷팅해야겠다.”

---

## 🧩 정리 요약

| 구분 | 핵심 목적 | 백엔드 관점 포인트 |
| --- | --- | --- |
| **Lo-Fi (로우파이)** | 전체 흐름과 구조 파악 | 필요한 데이터 / API 위치 감 잡기 |
| **Mid-Fi (미드파이)** | 기능별 화면 연결 명확화 | API 요청·응답 구조 논의 시작 |
| **Hi-Fi (하이파이)** | 실제 서비스 수준 디자인 완성 | 데이터 표현 방식, 포맷 세부 조율 |

---

## Q. **로우파이를 본 뒤 백엔드에서 어떤 항목을 문서화해두면 좋은지 (예: API 초안 표)**도 같이 정리해줘

로우파이(Lo-Fi)는 "기능의 흐름"과 "화면 간 관계"를 논의하는 단계이기 때문에, **백엔드 입장에서는 API 설계 전초전**으로 삼으면 딱 좋습니다.

즉, 로우파이를 보면서 “이 화면이 어떤 데이터를 표시하고, 어떤 요청을 보낼지”를 정리하면

나중에 API 명세서를 작성하거나 DB 스키마를 확장할 때 훨씬 빠르게 진행할 수 있습니다.

---

## 🧭 로우파이 확인 후 백엔드에서 문서화해두면 좋은 항목

### 📘 1. 화면 단위별 데이터 요구사항 정리표 (Screen → Data Mapping)

| 화면 이름 | 필요한 데이터 | 출처 (엔티티/테이블) | 비고 |
| --- | --- | --- | --- |
| 공간 목록 화면 | 공간 이름, 주소, 태그, 이미지, 찜 여부 | `Space`, `Tag`, `Wishlist` | 거리순 정렬 필요 |
| 공간 상세 화면 | 공간명, 이미지, 설명, 리뷰 평균, 호스트 정보 | `Space`, `Review`, `User` | 리뷰는 별도 요청 예정 |
| 리뷰 작성 화면 | 예약 ID, 별점, 내용 | `Reservation`, `Review` | 예약 ID 검증 필요 |

🟢 **이 표의 목적**:

- 각 화면이 어떤 데이터를 쓰는지 파악
- 나중에 API 응답 구조나 DB 쿼리 설계의 기준이 됨
- 프론트엔드와 협의 시 “이 화면에선 어떤 데이터를 받을까요?” 대화의 출발점

---

### ⚙️ 2. 예상 API 초안 표 (API Draft Spec)

| 구분 | 기능 | HTTP Method | Endpoint (예상 URL) | 요청(Request) | 응답(Response) |
| --- | --- | --- | --- | --- | --- |
| 공간 | 공간 목록 조회 | GET | `/spaces?lat=…&lng=…&radius=…` | 위치정보(lat, lng, radius) | 공간 리스트(JSON) |
| 공간 | 공간 상세 조회 | GET | `/spaces/{spaceId}` | spaceId | 공간 상세정보(JSON) |
| 리뷰 | 리뷰 등록 | POST | `/reviews` | `{reservationId, rating, content}` | 성공 메시지 or 생성된 리뷰 ID |
| 찜 | 찜 등록/해제 | POST | `/wishlist/{spaceId}` | spaceId | 상태 코드(찜됨/해제됨) |

🟢 **이 표의 목적**:

- API 이름, 요청·응답 방식, 주요 데이터 필드 미리 합의
- 프론트엔드 및 디자이너가 “이 버튼은 서버 통신이 필요하겠구나”를 인식하도록 돕기
- 개발 중 API 문서화(Swagger, Notion, Confluence 등)로 발전 가능

---

### 🧩 3. 데이터 흐름(Flow) 요약 다이어그램

> 간단한 표나 화살표 형태로 화면 간의 데이터 이동을 정리하면 좋아요.
> 

예시:

```
[홈 화면]
   ↓ (카테고리 선택)
[공간 목록 화면]
   ↓ (공간 클릭)
[공간 상세 화면]
   ↓ (리뷰 보기)
[리뷰 목록 화면]
   ↓ (리뷰 작성 클릭)
[리뷰 작성 화면]

```

🟢 **이 다이어그램의 목적**:

- 각 화면이 어떤 데이터 요청 순서를 따르는지 한눈에 파악
- 캐싱 전략, Lazy Loading, API 호출 우선순위를 설계할 때 기반이 됨

---

### 📄 4. 백엔드가 남겨두면 좋은 내부 기록 (정기회의 이후)

| 항목 | 내용 예시 |
| --- | --- |
| 신규 데이터 요구 | “공간 상세에 ‘호스트 이름’이 표시되므로 `User` 엔티티와 조인 필요.” |
| 예상 복잡도 | “리뷰 평균 계산은 실시간보단 예약 시점 업데이트로 최적화 가능.” |
| 기술적 의문 | “찜 기능은 로그인된 사용자만 가능하므로 토큰 검증 필요.” |
| 프론트 협의 필요 | “리뷰 등록 시 이미지 업로드는 단건인가, 다건인가?” |

🟢 **이 표의 목적**:

- 디자이너 회의 후 남는 **“서버에서 고려해야 할 이슈”**를 빠르게 기록
- 나중에 기능 명세서나 API 설계 시 바로 참고 가능

---

## ✅ 정리: 로우파이 → 백엔드가 준비해야 할 4단계

| 단계 | 문서화 항목 | 목표 |
| --- | --- | --- |
| ① | 화면별 데이터 요구표 | 어떤 데이터가 필요한지 정의 |
| ② | API 초안 표 | 요청·응답 구조 설계 초안 |
| ③ | 데이터 흐름 다이어그램 | 데이터 이동 경로 시각화 |
| ④ | 내부 기록표 | 기술적 이슈 및 협의사항 정리 |

---
